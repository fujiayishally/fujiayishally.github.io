<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[waving underline]]></title>
    <url>%2F2019%2F07%2F22%2Fwaving-underline%2F</url>
    <content type="text"><![CDATA[xxx🤔问题💡思路📚 定义👀 效果对比 🎉解决方案🚧注意🌵最后 这是 本例代码以供参考 本问题摘自xxx，致谢 点📖 查看更多xxx，致敬]]></content>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2019%2F07%2F17%2FBFC%2F</url>
    <content type="text"><![CDATA[xxx🤔问题💡思路🎉解决方案🚧注意🌵最后 这是 本例代码以供参考 本问题摘自xxx，致谢 点📖 查看更多xxx，致敬]]></content>
      <categories>
        <category>前端</category>
        <category>CSS相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[stacking context 层叠上下文]]></title>
    <url>%2F2019%2F07%2F17%2Fstacking-context%2F</url>
    <content type="text"><![CDATA[层叠上下文什么是层叠上下文？在CSS中，每个盒子的位置其实都是三维的。除了平面的X轴和Y轴之外，盒子还会沿着“Z轴”（垂直屏幕靠近用户方向）一个一个地往上堆叠，亦即产生了视觉上的重叠效果。看一下标准文档中给出的示意图： 这有个不太正确的类比，但也许能帮助你理解它们：层叠上下文就像JS中的执行上下文，内部维护了一些函数（元素盒子），不同函数在调用过程中形成了一个调用栈。元素盒子则是在定义时根据不同的定义方式获得了各自的层叠等级，它们按照层叠等级的高低也形成了一个栈，栈顶离用户最近。 层叠上下文分两种，一种是根元素&lt;body&gt;自动创建的根层叠上下文(root stacking context)，另一种是其他元素创建的本地层叠上下文( local stacking contexts)。每个盒子都必属于某个层叠上下文，但不是每个盒子都能创建层叠上下文。下面将整理创建层叠上下文的各种方式。 如何创建层叠上下文？当一个元素创建了层叠上下文，此时它和两个上下文有关：一个是它所处的当前层叠上下文，另一个是新层叠上下文。新层叠上下文属于当前层叠上下文的一部分。 创建层叠上下文的方法有： 前面提到的根元素&lt;body&gt;自动创建根层叠上下文 z-index:auto 和 z-index:0 的定位元素 For those with ‘z-index: auto’, treat the element as if it created a new stacking context, but any positioned descendants and descendants which actually create a new stacking context should be considered part of the parent stacking context, not this new one. 对于z-index:auto的定位元素，它的定位后代，以及能够创建层叠上下文的后代，都属于当前上下文。所以可认为 z-index:auto元素并没有创建层叠上下文，而不是像文档所说的”treat the element as if it created a new stacking context”。 For those with ‘z-index: 0’ treat the stacking context generated atomically. z-index:0 的定位元素自动创建层叠上下文。它的后代元素属于新创建的层叠上下，与z-index:0定位元素所在的层叠上下文中的其他元素无关。 元素的opactity属性值不为1。 元素的transform属性值不为none。 元素的filter属性值不为1。 当父元素是display:flex|inline-flex,后代元素的z-index不为auto 层叠等级什么是层叠等级？层叠上下文中可以包含多个元素盒子。每个盒子都有一个层叠等级（等级可以为负），层叠等级按大小排列形成了第三个轴——“Z轴”，垂直屏幕向用户延申增大。 需要注意的时层叠等级仅在当前层叠上下文中才有排序意义。创建当前层叠上下文的元素，相对再上一层的层叠上下文而言也有层叠等级。这两个层叠上下文中的层叠等级互不干扰。 同级的不一定是兄弟盒子，也可以是父子盒子；兄弟盒子也不一定等级相等；当等级相同时按 dom 树顺序从下到上堆叠。 有哪些层叠等级？在同一个层叠上下文中，会按照下面给出顺序逐层往上堆叠。当元素创建了新的层叠上下文，它会在其层叠作用域中从头再按顺序堆叠后代。 层叠等级顺序从低到高排列如下: background-color background-image border z-index 为负数 块级普通元素 float盒子 inline和inline-block盒子 等位元素 不依赖 z-index的创建层叠上下文元素 z-index &gt;= 0 的元素 1~3指的是创建当前层叠上下文的元素的背景和边框。这是一个易错点：当比较层叠等级时，往往会把dom树结构上的父元素背景视为一个层叠等级，但是父元素并不是创建当前层叠上下文的元素。 正确做法是，首先确定创建当前层叠上下文的元素是什么，然后不要受dom结构的影响，按照上面给出顺序排列元素等级。这些元素中有些能够创建新的层叠上下文，这可视为一个断层，新层叠上下文中的元素先跳过，等排列完当前层叠上下文的所有元素，再去排列子层叠上下文的元素。 🌵最后 本文的例子中参考了张鑫旭前辈《深入理解CSS中的层叠上下文和层叠顺序》一文，致谢 这里📖 是层叠上下文的标准文档，致敬]]></content>
      <categories>
        <category>前端</category>
        <category>CSS相关</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css filter 过滤器]]></title>
    <url>%2F2019%2F07%2F17%2Fcss-filter%2F</url>
    <content type="text"><![CDATA[📚 Filter 过滤器filter 的作用是调整图像、背景和边框的渲染效果，对其进行模糊、颜色偏移等图像处理。它有两种应用方式，一是作为CSS属性，调用预定义函数；二是作为SVG的滤镜元素。本文介绍的是前者。 下面会先简要列出 filter 的所有预处理函数及其作用和参数，然后整理成一份表格，罗列出不同预处理函数在不同参数下的图像渲染结果。希望这样的纵横对比能加深对filter的理解和记忆。 语法1&lt;filter&gt; : none | [ &lt;filter-function&gt; | &lt;url&gt; ]+ filter 过滤器可以重复设置； 预处理函数 亮度处理：brightness设置图像的亮度，取值 0% ~ &gt;100%，值取 0% 图像会全黑，值取 100% 则图像无变化，值 超过100% 图像会比原来更亮,默认是1。 1filter:brightness(0.4); 设置对比度 contrast设置图像对比度。取值 0% ~ &gt;100%，值取 0% 图像会全灰，值取 100% 则图像无变化，值 超过100% 图像会运用更低的对比,默认是1。 1filter: contrast(200%); 饱和度saturate设置图像饱和度，取值 0% ~ &gt;100%，值取 0% 图像完全不饱和，值取 100% 则图像无变化，值超过100% 图像有更高的饱和度。默认值1。 1filter: saturate(30%); 灰阶处理 grayscale设置图像灰度，取值 0%~100%，值取 0% 图像无变化，值取 100% 则为完全灰度图像，默认值0，不支持px。 1filter: grayscale(100%) 反转 invert设置图像反转比例。取值0%~100%，值取 0% 图像无变化，值取 100% 则图像完全反转，默认值 0。 1filter: invert(75%); 透明 opacity设置图像透明度，取值0%~100%，值取 0% 图像全透明，值取 100% 则图像无变化。默认值1。这个预定义函数与opacity属性的不同之处在于，一些浏览器为了提升性能会对filter提供硬件加速。 1filter: opacity(25%); sepia设置图像转为深褐色的转换比例，取值0%~100%，值取 0% 图像无变化，值取 100% 则图像完全深褐色，默认值 0。 1filter: sepia(60%); 色相旋转 hue-rotate给图像应用色相旋转。单位 deg ，默认值 0deg , 0deg ~ 360deg 为一周期。 1filter: hue-rotate(90deg); 模糊处理 blur设置图像的模糊度。取值即高斯模糊函数的标准差，简单理解就是设置了多大的值，就表示多少的像素会融在一起。所以值越大越模糊。单位为px，不支持%。默认值为0。 1filter: blur(5px); 阴影drop-shadow设置图像阴影，除了没有 inset 关键字，其他设置与 box-shadow 很相似。 1filter: drop-shadow(16px 16px 10px black) 👀 效果对比 .img{ width:100%; height:3em; display:inline-block; background:url(https://fujiayishally.github.io/images/header.jpg) 0 / cover; border: solid 1px black; } .brightness1{filter:brightness(0%);} .brightness2{filter:brightness(50%);} .brightness3{filter:brightness(100%);} .brightness4{filter:brightness(150%);} .brightness5{filter:brightness(1000%);} .contrast1{filter:contrast(0%);} .contrast2{filter:contrast(50%);} .contrast3{filter:contrast(100%);} .contrast4{filter:contrast(150%);} .contrast5{filter:contrast(1000%);} .saturate1{filter:saturate(0%);} .saturate2{filter:saturate(50%);} .saturate3{filter:saturate(100%);} .saturate4{filter:saturate(150%);} .saturate5{filter:saturate(1000%);} .grayscale1{filter:grayscale(0%);} .grayscale2{filter:grayscale(25%);} .grayscale3{filter:grayscale(50%);} .grayscale4{filter:grayscale(75%);} .grayscale5{filter:grayscale(100%);} .invert1{filter:invert(0%);} .invert2{filter:invert(25%);} .invert3{filter:invert(50%);} .invert4{filter:invert(75%);} .invert5{filter:invert(100%);} .opacity1{filter:opacity(0%);} .opacity2{filter:opacity(25%);} .opacity3{filter:opacity(50%);} .opacity4{filter:opacity(75%);} .opacity5{filter:opacity(100%);} .sepia1{filter:sepia(0%);} .sepia2{filter:sepia(25%);} .sepia3{filter:sepia(50%);} .sepia4{filter:sepia(75%);} .sepia5{filter:sepia(100%);} .hue-rotate1{filter:hue-rotate(0deg);} .hue-rotate2{filter:hue-rotate(90deg);} .hue-rotate3{filter:hue-rotate(180deg);} .hue-rotate4{filter:hue-rotate(270deg);} .hue-rotate5{filter:hue-rotate(360deg);} .blur1{filter:blur(0px);} .blur2{filter:blur(1px);} .blur3{filter:blur(5px);} .blur4{filter:blur(20px);} .blur5{filter:blur(100px);} .drop-shadow1{filter: drop-shadow(0px 0px 0px black);} .drop-shadow2{filter: drop-shadow(0px 0px 10px black);} .drop-shadow3{filter: drop-shadow(10px 0px 10px black);} .drop-shadow4{filter: drop-shadow(0px 10px 10px black);} .drop-shadow5{filter: drop-shadow(10px 10px 10px black);} brightness0%50%100%150%1000% contrast0%50%100%150%1000% saturate0%50%100%150%1000% grayscale0%25%50%75%100% invert0%25%50%75%100% opacity0%25%50%75%100% sepia0%25%50%75%100% hue-rotate0deg90deg180deg270deg360deg blur0px1px5px20px100px drop-shadow0px 0px 0px black0px 0px 10px black10px 0px 10px black0px 10px 10px10px 10px 10px black 🚧 注意 预处理函数是作用于整个元素的，即使边框也会受到影响 某些函数处理后，元素的渲染范围已经超出了元素本身，例如 blur 函数。 🌵最后 点📖 查看MDN相关文档，或者点📖 查看标准文档，致敬]]></content>
      <categories>
        <category>前端</category>
        <category>CSS属性</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS clip-path 剪切属性]]></title>
    <url>%2F2019%2F07%2F16%2FCSS-clip-path%2F</url>
    <content type="text"><![CDATA[📚 CSS clip-path 剪切clip-path 属性（替代已经弃用的clip属性）用于裁剪元素，支持逗号赋值。 语法12345clip-path:&lt;clip-source&gt; | [ &lt;basic-shape&gt; || &lt;geometry-box&gt; ] | none&lt;clip-source&gt;:url(resources.svg#c1);&lt;geometry-box&gt;:clip-path: margin-box | border-box | padding-box | content-box | fill-box | stroke-box | view-box;&lt;basic-shape&gt;:clip-path: inset() | circle()| ellipse() | polyon() | &lt;shape-box&gt; 预定义函数在左上角为（0%，0%），右下角为（100%，100%）的坐标轴中，调用预定义的函数设置裁剪边框： inset( 上右下左的边距 round 上右下左圆角 )裁剪內置矩形 1clip-path:inset(10px 20px 30px 10px round 20px 5px 50px 0); circle(半径 at 圆心坐标) 裁剪圆形 1clip-path:circle(50% at 50% 50%); ![圆形裁剪分析图](2019-07-16-CSS-clip-path/circle.JPG) ellipse(长短轴半径 at 圆心坐标) 裁剪椭圆形 1clip-path:ellipse(25% 50% at 50% 50%); polyon(顶点坐标) 裁剪多边形定义多边形各个顶点坐标，直线勾连顶点圈出裁剪区域。需要过渡效果时必须注意，例如裁剪三角形： 1clip-path:polygon(0% 100%, 50% 0%,100% 100%); 另外如果需要过渡效果就必须注意：polygon点坐标的数目在动画的前后数目要一样。 👀 效果对比多边形裁剪polygon .source{ background:url(https://fujiayishally.github.io/images/header.jpg) center/cover; width:100px;height:100px; } .polygon1{clip-path: polygon(0% 100%, 50% 0%,100% 100%);} .polygon2{clip-path: polygon(polygon(0% 0%, 0% 100%,100% 100%,100% 0%));} .polygon3{clip-path: polygon(0% 38.31%, 50% 0%,100% 38.31%,80.86% 100%,19.14% 100%);} .polygon4{clip-path: polygon(25% 0%, 75% 0%,100% 50%,75% 100%,25% 100%,0% 50%);} .polygon5{clip-path: polygon(50% 0%, 90.18% 19.72%,100% 64.22%,72.32% 100%,27.68% 100%,0% 64.22%,10.09% 19.72%);} .polygon6{clip-path: polygon(29.34% 0%, 70.66% 0%,100% 29.34%,100% 70.66%,70.66% 100%,29.34% 100%,0% 70.66%,0% 29.34%);} 多边形 效果图 代码 三角形 polygon(0% 100%, 50% 0%,100% 100%) 正方形 polygon(0% 0%, 0% 100%,100% 100%,100% 0%) 正五边形 polygon(0% 38.31%, 50% 0%,100% 38.31%,80.86% 100%,19.14% 100%) 正六边形 polygon(25% 0%, 75% 0%,100% 50%,75% 100%,25% 100%,0% 50%) 正七边形 polygon(50% 0%, 90.18% 19.72%,100% 64.22%,72.32% 100%,27.68% 100%,0% 64.22%,10.09% 19.72%) 正八边形 polygon(29.34% 0%, 70.66% 0%,100% 29.34%,100% 70.66%,70.66% 100%,29.34% 100%,0% 70.66%,0% 29.34%) 动画效果demo1 .demo1 { transition: 0.4s cubic-bezier(1, -1, 0, 2); clip-path: circle(50px at 60px 60px); width:120px;height:120px; } .demo1:hover { clip-path: circle(55px at 60px 60px); } 12345678.demo1 &#123; transition: 0.4s cubic-bezier(1, -1, 0, 2); clip-path: circle(50px at 60px 60px); width:120px;height:120px;&#125;.demo1:hover &#123; clip-path: circle(55px at 60px 60px);&#125; demo2 .demo2 { transition:0.5s; clip-path: polygon(0% 50%, 10% 40%, 10% 48%, 90% 48%, 90% 40%, 100% 50%, 90% 60%, 90% 52%, 10% 52%, 10% 60%); width:100px; height:100px; background:black; position:relative; } .demo2:before{ content: ''; position: absolute; top:40%; left:15%; width: 5px; height: 5px; border-radius: 3px; background-color: #fff; } .demo2:hover { clip-path:polygon(0% 53%, 0% 47%, 20% 30%, 60% 30%, 90% 50%, 100% 65%, 100% 35%, 90% 52%, 60% 70%, 20% 70%); } 1234567891011121314151617181920.demo2 &#123; transition:0.5s; clip-path: polygon(0% 50%, 10% 40%, 10% 48%, 90% 48%, 90% 40%, 100% 50%, 90% 60%, 90% 52%, 10% 52%, 10% 60%); height:100px; background:black; position:relative;&#125;.demo2:before&#123; content: ''; position: absolute; top:40%; left:15%; width: 5px; height: 5px; border-radius: 3px; background-color: #fff;&#125;.demo2:hover &#123; clip-path:polygon(0% 53%, 0% 47%, 20% 30%, 60% 30%, 90% 50%, 100% 65%, 100% 35%, 90% 52%, 60% 70%, 20% 70%);&#125; 🌵最后 这是一个clip-path在线制作工具 点📖 查看MDN上的介绍，致敬 多边形例子及裁剪分析图参考了这篇文章,致谢 一个超级棒的动物变换例子页面👍]]></content>
      <categories>
        <category>前端</category>
        <category>CSS属性</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[frosted glass 毛玻璃效果]]></title>
    <url>%2F2019%2F07%2F16%2Ffrosted-glass%2F</url>
    <content type="text"><![CDATA[🤔问题当背景图太过花哨，使得内容层的文字难以阅读时，应该怎么办呢？ 我的想法是常规地添加个透明背景： 黑底白字 白底黑子 说实话，加了背景色之后虽然能看清文字了，可大大一块颜色不怎么好看呀。有什么办法能让文字和背景图更好地融合呢？毛玻璃可能是个不错的选择。 什么是毛玻璃效果？看看QQ音乐歌词的界面就知道了。歌词能很清楚地被看到，因为文本覆盖的图片区域被大大地模糊了，人在阅读时就会更专注于清晰可辨的文字。 💡思路模糊效果可以用 filter过滤器的 blur 方法来实现。如果你脑海中还不能马上浮现 filter 的知识图谱，不妨阅读一下MDN文档或者我整理的这篇CSS Filter 。 如果直接对元素使用blur，文字也会变得模糊: 1filter:blur(2px); 怎么才能让元素覆盖区域背景模糊，而又不影响文字的现实呢？可以在背景图元素和内容元素之间加一个中间层。它需要满足几个要求： 中间层渲染的图像能与背景元素图像无缝衔接 中间层与内容元素盒子等大 由中间层实现模糊效果，内容元素叠加其上 中间层应该是内容层的子元素盒子，能直接获取父元素大小。又因为是纯样式效果，比起增加一个div子元素，使用伪元素更利于维护DOM结构。 🎉解决方案解决问题的关键时如何让伪元素与背景元素拥有无缝衔接的背景图。 background-attachment:fixed 的作用是让背景图相对视窗固定。当背景元素和伪元素都设置相同背景属性，并且背景相对视窗固定时，就达到视觉上的无缝衔接效果： 12345background:url(https://cdn.pixabay.com/photo/2016/02/19/10/51/stairs-1209439__340.jpg) no-repeat;background-size:50% auto;background-position:50% 0%;background-attachment:fixed;border:solid 1px black; 伪元素继承父元素的大小(背景色是为了方便调试) 1234567.content:after&#123; content:''; position:absolute; top:0;right:0;bottom:0;left:0; filter:blur(20px); background:blue;&#125; 效果是这样的： 伪元素挡住了内容元素！这是理所当然的，因为伪元素某种意义上来说，相当于内容元素的子元素,且它绝对定位覆盖了父元素。所以需要手动调整伪元素的层叠顺序： 1234.content:after&#123; ... index:-1;&#125; 但是没能解决问题： 伪元素的层叠顺序不仅排在了内容元素后面，也排在了背景元素后面，为什么呢？ 因为背景元素、内容元素、和伪元素都处于同一层叠上下文中，z-index为负值时，它的层叠顺序会在普通元素盒子之后。解决办法是让内容元素拥有层叠上下文，这样伪元素的层叠顺序就与外界无关了。 创建层叠上下文的方式之一，是设置z-index为非 auto值： 1234.content&#123; ... z-index:0;&#125; 有进展了！伪元素渲染在背景元素之前。接下来的问题：一是伪元素的模糊效果出圈了。二是边缘处模糊效果减弱，透出了背景图： 前者简单，一句 overflow:hidden 就能解决。后者是因为模糊效果的削减幅度是模糊半径的长度，只要伪元素再向外扩展至少20px即可： 123456789.content&#123; ... overflow:hidden;&#125;.content:before&#123; ... margin:-50px;//保险起见，设置一个比20px更大的值&#125; 去掉蓝色背景，最终的渲染效果： 🚧注意上述解决方案有个明显的确定，因为background-attachment:fixed 是相对视窗固定，当出现滚动条时，背景会随着视窗固定，而内容会随着滚动条滚动： 要想内容和背景滚动一致，就需要计算调整伪元素背景的大小和位置，使得其显示部分能够尽量和被背景元素的图像衔接上： 1234567891011121314151617181920.background&#123; background-image: url(https://cdn.pixabay.com/photo/2016/02/19/10/51/stairs-1209439__340.jpg); background-size:100%; background-position:0 0; width:50%; ...&#125;.content&#123; width:80%; padding:1em; margin:2em auto; box-sizing:border-box; ...&#125;.content2:before&#123; background-size:125%; background-position:50% -2em; ...&#125; 三个元素联系紧密，不管是初始配置还是后续修改，都需要三者兼顾来实现效果。可维护性不太友好，但是背景和内容滚动同步。 🌵最后 这是 本例代码，以供参考 本问题摘自《CSS揭秘》–Lea Verou的第十八章，致谢 点📖 查看更多过滤器标准内容]]></content>
      <categories>
        <category>前端</category>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[multiple borders 多重边框]]></title>
    <url>%2F2019%2F07%2F16%2Fmultiple-borders%2F</url>
    <content type="text"><![CDATA[🤔问题怎么让一个元素现实出多个边框的效果呢？心里面的第一反应是多个元素嵌套层叠，给出视觉效果上的“多边框”。但这并不是真正的多边框不是吗？ 💡思路既然是边框的问题，就让“边框”来解决。border边框属性不支持逗号分隔的多个值，所以只能实现一层。之外还能对元素边界产生视觉的效果的元素还有 盒子模型的outline 以及 用作边框效果的box-shadow。 outlineoutline通常通常用于突出某个可视对象，标准语法如下： 1&lt;outline&gt;: [ &lt;outline-color&gt; || &lt;outline-style&gt; || &lt;outline-width&gt; ] 其实 outline 和 border 的属性设置是很相似的，它也可以选择样式，同样不支持逗号分割多值。此外，outline 还受偏移属性 outline-offset 控制。那么如果需要更多层的边框怎么办呢？你可以考虑一下box-shadow。 box-shadowbox-shadow可以产生一个或多个下拉阴影框，标准语法如下： 1&lt;shadow&gt; = inset？ &amp;&amp; &lt;length&gt; &#123;2,4&#125; &amp;&amp; &lt;color&gt; ？ 第二部分的 &lt;length&gt; 值的个数是{2,4}，表示在[水平偏移，垂直偏移，模糊半径，传播距离]中从左到右选择两到四个赋值。传播距离是往往被忽略的一个值。现在设想如果一个阴影不偏移，不模糊，有一个传播距离，那么呈现出来的效果不就是一个边框吗？而且这个“边框”是可以多个的。 当然 box-shadow 并非完美无缺的，它只能用来模拟实线边框，如果需要虚线效果，它是没辙的。 下面我们来具体看看两个属性实现多重边框的效果吧。 🎉解决方案为了便于比较，每个盒子都设置了一样的通用样式： 12345width:200px;height:100px;box-sizing:border-box;text-align:center;background-color:rgba(253,234,171,0.5); outline方案12border:10px dashed rgba(0,0,255,0.3);outline:10px solid rgba(0,255,0,0.3); 效果图： box-shadow方案外阴影123border:10px dashed rgba(0,0,255,0.3);box-shadow: 0 0 0 10px rgba(0,255,0,0.3), 0 0 0 20px rgba(255,0,0,0.3); 效果图： 内阴影123border:10px dashed rgba(0,0,255,0.3);box-shadow: 0 0 0 10px rgba(0,255,0,0.3) inset, 0 0 0 20px rgba(255,0,0,0.3) inset; 效果图： 🚧注意看起来还不错是不是？不过有些地方还是需要注意的。 圆角问题outline 不一定会贴合 border-radius 属性产生的圆角，这个被CSS工作组认为是一个bug，未来可能会修复。但目前而言，需要根据实际情况谨慎测试使用。box-shadow 就不会有这个问题。看看加上圆角后的不同效果： outline 外阴影 内阴影 布局影响outline标准文档中给出了outline 和 border 的区别，其中一点就是 Outlines do not take up space.(outline不占空间) 对此进一步的解析是： the outline is always on top, and doesn’t influence the position or size of the box, or of any other boxes. Therefore, displaying or suppressing outlines does not cause reflow.（outline 一直渲染在元素顶层，不影响自身盒子的位置、大小，也不影响其他盒子。所以，它的显示与否并不会引起回流） box-shadow标准文档中也给出了相关细节： Shadows do not influence layout and may overlap other boxes or their shadows. （阴影不会影响布局，它可以与其他框或阴影重叠） 对比为了看出两者在布局上不同，我给圆角中的例子外层又套了一层等大小的父容器： 1234width:200px;height:100px;border:1px dashed black;margin:50px; 看看效果： outline 外阴影 内阴影 box-shadow的渲染既然阴影可以有多层，那么阴影顺序是怎样的呢？ The shadow effects are applied front-to-back: the first shadow is on top and the others are layered behind. （阴影之间第一个位于顶部，其他在它后面） …the outer box-shadows of an element are drawn immediately below the background of that element…(外阴影绘制在元素背景下方) … the inner shadows of an element are drawn immediately above the background of that element.(内阴影绘制在元素背景上方) 也就是说，阴影是层层叠加的，传播距离的长度需要递增，否则会被挡住。外阴影和内阴影不是连续的，中间隔着背景和边框。 还有一点要注意的是，外阴影不会触发鼠标点击或悬停，也不会触发滚动或增加可滚动区域的大小。弥补办法是： 通过 margin（外阴影）和padding（内阴影）模拟边框所占空间进行弥补， 如果对鼠标悬停有要求，应该选择内阴影而不是外阴影 🌵最后 这是 本例代码以供参考 本问题摘自《CSS揭秘》–Lea Verou的第二章，致谢 点📖 查看更多CSS3背景标准，点📖 查看更多用户界面模块标准，致敬]]></content>
      <categories>
        <category>前端</category>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[translucent borders 透明的边框]]></title>
    <url>%2F2019%2F07%2F16%2Ftranslucent-borders%2F</url>
    <content type="text"><![CDATA[🤔问题假设想给一个容器设置一个白色背景和一道半透明白色边框，body背景从半透明边框透出来，该如何实现呢？ 💡思路大部分人首先想到的代码可能是这样的： 12border:2em solid rgba(255,255,255,0.5);background:white; 但渲染出来的结果却不如意： 边框去哪了？再看看去掉白色背景后的渲染结果： 原来是背景色垫在边框下面，半透明的边框看不出来了。也就是说，元素的背景色有效范围是边框外边沿。 那么背景图的有效范围呢？把代码修改一下： 12border:2em solid rgba(255,255,255,0.5);background-image: linear-gradient(white 100%,transparent); 渲染结果和白色背景色时一样： 🎉解决方案这样解决办法就很明确了，让背景的边框渲染范围在边框内即可。但对于一个盒子而言，CSS2中无法实现。标准中明确表示过： Note that the background is always drawn behind the border, if any … in [CSS2]. 请注意，背景始终绘制在边框后面（如果有）。 针对这个问题，CSS3中添加了background-clip 属性，用于确定背景绘制区域。它有三个具值： border-box：(初始值)背景被绘制在（剪切到）边框内 padding-box ：背景被绘制在（填充）填充框内。 content-box：背景被绘制在（剪切到）内容框中 对比下三个效果： border-box padding-box content-box 🚧注意CSS3背景中还有另外一个属性background-origin属性,用于确定背景定位区域。它也有三个具值： padding-box：（默认值）该位置相对于填充框。 border-box ：该位置相对于边框。 content-box：该位置相对于内容框。 给出如下代码： 123background-color:#ffb6b9;padding:1em;border:1em solid hsla(0,0%,100%,0.5); 然后分别控制 background-origin 的值，对比下效果： border-box padding-box(默认) content-box 可以看出，background-origin 控制的是背景图的开始渲染位置（0,0）是相对于border、padding、还是content，而不是渲染范围。 🌵最后 这是 半透明边框的代码 本问题摘自《CSS揭秘》–Lea Verou的第一章，致谢 点一下 📖 查看更多CSS3背景标准，致敬]]></content>
      <categories>
        <category>前端</category>
        <category>CSS样式</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS:linear-gradient 线性渐变]]></title>
    <url>%2F2019%2F07%2F11%2FCSS-gradient%2F</url>
    <content type="text"><![CDATA[线性渐变CSS3线性渐变的标准写法： 1background-image: linear-gradient([&lt;angle&gt; | &lt;side-or-corner&gt;,]? &lt;color-stop&gt; [,&lt;color-stop&gt;]+ ); 可以看出，线性渐变效果由方向（&lt;angle&gt; | &lt;side-or-corner&gt;可选）及起止色（color-stop至少一对）控制。下面将通过控制变量法，分别对这两者进行分析。 控制渐变方向要明白渐变方向是怎样控制的，首先要明确三个规定： 规定 0deg 时方向为上 规定 0deg 到 180deg 是顺时针方向 默认方向是 180deg, 向下 两个颜色的渐变描述起来是这样的：颜色A 沿着指定方向过渡到 颜色B，例如为两个颜色white和black设置渐变方向： to bottom，就是 white 沿着向下方向过渡到 black 45deg，就是 white 沿着 45deg 方向过渡到 颜色B（black） 下面我用不同的方向值替换代码中的 to bottom 来加深理解： 1background: linear-gradient(to botton,white, black) .block{width:100%;height:3em;display:inline-block;} .linear1-1{background:linear-gradient(white,black);} .linear1-2{background:linear-gradient(to bottom,white,black);} .linear1-3{background:linear-gradient(to top,white,black);} .linear1-4{background:linear-gradient(to left,white,black);} .linear1-5{background:linear-gradient(to right, white,black);} .linear1-6{background:linear-gradient(to left top,white,black);} .linear1-7{background:linear-gradient(to right top,white,black);} .linear1-8{background:linear-gradient(to left bottom,white,black);} .linear1-9{background:linear-gradient(to right bottom,white,black);} .linear1-10{background:linear-gradient(180deg,white,black);} .linear1-11{background:linear-gradient(180deg,white,black);} .linear1-12{background:linear-gradient(0deg,white,black);} .linear1-13{background:linear-gradient(-90deg,white,black);} .linear1-14{background:linear-gradient(90deg,white,black);} .linear1-15{background:linear-gradient(-45deg,white,black);} .linear1-16{background:linear-gradient(45deg,white,black);} .linear1-17{background:linear-gradient(-135deg,white,black);} .linear1-18{background:linear-gradient(135deg,white,black);} 关键词 效果 角度 效果 默认 180deg to bottom 180deg to top 0deg to left -90deg to right 90deg to left top -45deg to right top 45deg to left bottom -135deg to right bottom 135deg 方向关键词的制订是有一个演变历史的。 控制起止颜色 &lt;color-stop&gt;起止颜色不仅仅是值两个颜色值，还包括颜色的长度。它的赋值语法是： 1&lt;color|stop&gt; [ &lt;percentage&gt; | &lt;length&gt; ] 如何理解 “颜色的长度” 呢？借用一下张鑫旭前辈一篇博文中的例子： 在一个400*300的 div 上实现一个 (100px, 100px) 到 (200px, 200px) 由红到黄的斜向线性渐变，该如何实现？ 一图胜千言，根据上图分析的步骤是： 找出渐变方向：连接两个作用点，角度是135deg 找默认起止点：沿渐变方向画直线穿过元素中心（xy轴垂线交点），在元素渐变方向的两端，画两条渐变线的垂线，交点即默认起止点 确定颜色长度：穿过作用点画渐变线垂线，交点与开始点的距离就是长度，求它的值 $$RedLen = 100*\sqrt{2} = 141$$ $$YellowLen = 200*\sqrt{2} = 282$$ 代码： 1background-image:linear-gradient(135deg,red 141px,yellow 282px); 最终的渲染效果： 下面将沿着从左到右的方向，通过控制颜色数和长度变量，看下各种配置在40*30的元素中如何渲(为了方便表示，r:red，y:yellow，g:green)： .block2{width:100%;height:3em;display:inline-block;} .linear2-1{background:linear-gradient(to right,yellow 0%,red 0%);} .linear2-2{background:linear-gradient(to right,yellow 0%,red 50%);} .linear2-3{background:linear-gradient(to right,yellow 0%,red 100%);} .linear2-4{background:linear-gradient(to right,yellow 25%,red 0%);} .linear2-5{background:linear-gradient(to right,yellow 25%,red 50%);} .linear2-6{background:linear-gradient(to right,yellow 50%,red 50%);} .linear2-7{background:linear-gradient(to right,yellow 50%,red 100%);} .linear2-8{background:linear-gradient(to right,yellow 100%,red 100%);} .linear2-9{background:linear-gradient(to right,yellow 100%,red 0%);} .linear2-10{background:linear-gradient(to right,yellow 0%,red 0%,green 0%);} .linear2-11{background:linear-gradient(to right,yellow 0%,red 50%,green 100%);} .linear2-12{background:linear-gradient(to right,yellow 25%,red 0%,green 100%);} .linear2-13{background:linear-gradient(to right,yellow 25%,red 25%,green 100%);} .linear2-14{background:linear-gradient(to right,yellow 25%,red 50%,green 100%);} .linear2-15{background:linear-gradient(to right,yellow 25%,red 100%,green 100%);} .linear2-16{background:linear-gradient(to right,yellow 100%,red 50%,green 100%);} .linear2-17{background:linear-gradient(to right,yellow 50%,red 50%,green 50%);} .linear2-18{background:linear-gradient(to right,yellow 100%,red 100%,green 100%);} .linear2-31{background:linear-gradient(to right,yellow 0%,red 100%);} .linear2-32{background:linear-gradient(to right,yellow -100%,red 100%);} .linear2-33{background:linear-gradient(to right,yellow 0%,red 200%);} .linear2-34{background:linear-gradient(to right,yellow -100%,red 200%);} .linear2-35{background:linear-gradient(to right,yellow 20%, red 30%, red 45%, green 55%, green 70%, blue 80% );} .linear2-36{background:linear-gradient(to right,yellow 20%, red 30% 45%, green 55% 70%, blue 80%);} .linear2-37{background:linear-gradient(to right,yellow 25%, red 25%, red 50%, green 50%, green 75%, blue 75%);} .linear2-38{background:linear-gradient(to right, yellow 25%, red 25% 50%, green 50% 75%, blue 75%);} 两个颜色(yellow,red) 效果 三个颜色(yellow,red,green) 效果 其他 效果 0%,0% 0%,0%,0% y0%,r100% 0%,50% 0%,50%,100% y-100%,r100% 0%,100% 25%,0%,100% y0%,r200% 25%,0% 25%,25%,100% y-100%,r200% 25%,50% 25%,50%,100% y20%,r30%,r45%,g55%,g70%,b80% 50%,50% 25%,100%,100% r30% 45%,g55% 70%,b80% 50%,100% 100%,50%,100% y25%,r25%,r50%,g50%,g75%,b75% 100%,100% 50%,50%,50% y25%,r25% 50%,g50% 75%,b75% 100%,0% 100%,100%,100% - - 由上表总结就是： 后设颜色长度不能少于前一个颜色长度 下一个颜色会覆盖前一个颜色 两个不同颜色间存在距离才能看出渐变效果，否则就是拼接效果 起止点可以设置超过范围的值 除了设置颜色长度，还可通过设置两个颜色的过渡中心点位置来控制渐变。看看两者的不同： 设置颜色长度: 1background-image:linear-gradient(to right, red 0%, yellow 100%); 设置中心点: 1background-image:linear-gradient(to right, red, 50%, yellow); 来个复杂的 默认情况： 1background-image:linear-gradient(to right, red, yellow, green, blue); 设置颜色长度： 1background-image:linear-gradient(to right, red 0%, yellow 33.33%, green 66.66%, blue 100%); 设置中心点： 1background-image:linear-gradient(to right, red, 16.67%, yellow, 50%, green, 83.33%, blue); 重复渐变当渐变效果是重复性的，就可以用另外一个函数 repeating-linear-gradient来渲染。它的语法规则是这样子的： 1repeating-linear-gradient( [ &lt;angle&gt; | to &lt;side-or-corner&gt; ,]? &lt;color-stop&gt; [, &lt;color-stop&gt;]+ ) 定义时，只需要设置最小精度过渡样式，重复部分交给渲染引擎。另外，为了更好的过渡效果，第一个和最后一个颜色应该相等。下表中会用变量替换指令的 red,yellow，感受下效果： 1background:repeating-linear-gradient(to right,red,yellow); .block3{width:100%;height:3em;display:inline-block;} .linear3-1{background:repeating-linear-gradient(to right,red,yellow);} .linear3-2{background:repeating-linear-gradient(to right,red 0%,yellow 100%);} .linear3-3{background:repeating-linear-gradient(to right,red, red 12.5%, yellow 25%);} .linear3-4{background:repeating-linear-gradient(to right,red,red 12.5%, yellow 12.5%,yellow 25%);} .linear3-5{background:repeating-linear-gradient(to right,red,red 7.5%, yellow 7.5%,yellow 15%);} .linear3-6{background:repeating-linear-gradient(to right,red,yellow 6.25%, red 12.5%);} 变量 效果 red,yellow r0%,y100% r,r12.5%,y25% r,r12.5%,y12.5%,y25% r,r3px,y7.5%,y15% r,y6.25%,r12.5% 重复渐变可以做出多规律性的效果： .linear3-7{background:repeating-linear-gradient(180deg, #8ac6d1,#8ac6d1 7px, #fbd1b7 7px,#fbd1b7 9px);} .linear3-8{background:repeating-linear-gradient(135deg, black,black 3.75%, white 3.75%,white 7.5%);} 方向 效果 180deg 135deg 效果叠加渐变效果是可以叠加的，并且渐变颜色可以选择 transparent。 兼容性渐变效果在 没有-&gt;提案-&gt;各浏览器带前缀实现-&gt;标准化-&gt;去前缀 过程中有所变迁，不同浏览器是否带前缀和是否带 to 关键词的实现混杂， MDN 最终给出下面跨浏览器兼容实现： 1234567.grad &#123; background-color: white; /* 不支持渐变的浏览器回退方案 */ background-image: -webkit-linear-gradient(top, black, white); /* 支持 Chrome 25 and Safari 6, iOS 6.1, Android 4.3 */ background-image: -moz-linear-gradient(top,black, white); /* 支持 Firefox (3.6 to 15) */ background-image: -o-linear-gradient(top,black, white); /* 支持旧 Opera (11.1 to 12.0) */ background-image: linear-gradient(to bottom,black, white); /* 标准语法; 需要最新版本 */&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS属性</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各类资源网站集]]></title>
    <url>%2F2019%2F07%2F11%2Fbookmarks%2F</url>
    <content type="text"><![CDATA[资源篇图片资源 pixabay:查找和分享免费的无版权图像，图片质量佳 unsplash:图片多是风景和静物 谷歌艺术&amp;文化:提供大量高清艺术作品和历史人物、事件的高清图片 素材资源 easyicon:提供不同尺寸的png、ico等格式图标供下载 iconfont:阿里巴巴旗下的图标库网站 奥森图标:提供丰富的矢量字体图标 千库网:免费下载图片素材的网站 有字库:一个免下载字体，直接在线引用字体的网站 PS字体库: 包含了几乎所有类型的字体，下载好安装，PS中就可以使用 插件资源 jQuery插件1:分享jQuery插件的详细使用方法,在线预览,jQuery插件下载及教程 jQuery插件2:与上一个网站类似，也提供了大量的jQuery插件 layui:强大的模块化前端框架 工具篇颜色处理工具 配色方案-纯色:颜色搭配佳，可直接复制 配色方案-渐变色:可直接复制渐变css代码 颜色提取:根据上传的图片提取颜色 安全色大全:网站开发中经常用到的安全色方案 颜色转换工具:在线RGB和十六进制颜色码转换工具 在线图片压缩1:可以批量使用 在线图片压缩2:较之上者，可自定义压缩质量 UI设计工具集 在线工具集 框架篇 Element UI :一套为开发者、设计师和产品经理准备的开源组件库 Muse UI:基于 Vue 2.0 优雅的 Material Design UI 组件库 Vant:轻量、可靠的移动端 Vue 组件库 Amaze UI:中国首个开源 HTML5 跨屏前端框架 iView admin: 搭配使用iView UI组件库形成的一套后台集成解决方案]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具指令备忘集]]></title>
    <url>%2F2018%2F11%2F11%2Ftools%2F</url>
    <content type="text"><![CDATA[hexohexo是一个博客框架，能够快速生成静态网页。支持评论、访问数统计等功能插件扩展。可以和Github域名绑定。 定制主题和安装插件我选择的hexo主题是 NextT (因为很多人用)。需要自定义插件和修改主题样式时，可以看这篇NexT主题的优化定制修改指南。作者分门别类地收集了主题配置的各种可行操作，并预先踩实了官方文档中的一些坑，感谢。 部署到github在站点配置文件 _config.yml中配置部署文件 1234deploy: type: git repo: git@github.com:yourGitHubName/yourGitHubName.github.io.git branch: master 部署类型是git，需要安装相关工具包，否则报错Deployer not found: gitgit： 1npm install hexo-deployer-git --save 此时可以运行下面指令，构建静态页面并上传到Github 1hexo d 相关指令集1hexo new &quot;学习笔记 一&quot; 新建一篇标题为 “学习笔记 一” 的文章，因为标题里有空格，所以加上了引号（也即普通命名不加引号也时可以的）。 1hexo s hexo server 的缩写，能够启动一个本地服务器，默认为地址：http://localhost:4000/。 1hexo g hexo generate 的缩写，生成网站静态文件到默认设置的 public 文件夹 12hexo dhexo d --g hexo deploy 的缩写,第一条指令用于把静态文件部署到设定仓库。如果希望生成静态文件之后直接部署，可使用第二条指令。 1hexo clean 清除缓存文件 db.json 和已生成的静态文件 public 。网站显示异常时可以执行这条命令试试。 1hexo new page aboutme 新建一个标题为 aboutme 的页面，默认链接地址为 主页地址/aboutme/ 博文中插入图片如果博文中需要插入图片，则需要在站点配置文件 _config.yml 修改下面两个字段： 123post_asset_folder:true...url: https://YourName.github.io 并且安装插件： 1npm install hexo-asset-image --save 打开 /node_modules/hexo-asset-image/index.js，将内容更换为下面的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 此后，每次新建博文的同时会多生成一个同名文件，用于存放该博文需要插入的图片。在博文中这么引用图片： 1![你想输入的替代文字](图片名.jpg) 启用数学公式符号主题配置文件设置mathjax属性： 1234mathjax: enable: true per_page: true cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 并在需要引用公式的文章中手动设置： 123456---title: index.htmldate: 2016-12-28 21:01:30tags:mathjax: true--- GitGit 是一个分布是版本控制工具，和Github结合强无敌。本地安装好Git之后，想要和Github配合工作还需要一些配置。 配置账号用户名和邮箱应该与在Github上注册的一致 12git config --global user.email "you@example.com"git config --global user.name "Your Name" 配置SSH公钥Git服务器使用SSH公钥进行验证，要证明当前电脑具有提交权限就要手持一份在Github上注册了的SSH公钥。按照官方文档说的“我们需要寻找一对以 id_dsa 或 id_rsa 命名的文件，其中一个带有 .pub 扩展名。 .pub 文件是你的公钥，另一个则是私钥。” 首先，确认自己是否已经拥有密钥。打开Git Bash，输入： 12$ cd ~/.ssh$ ls 如果没看到上述两个文件（或者根本没有 .ssh 目录），可运行 ssh-keygen 生成： 1$ ssh-keygen 执行完后，可看到如下提示： 再次进入 .ssh 文件就可以看到生成的钥匙了。打开 id_rsa.pub文件，并把里面的内容复制到 GitHub &gt; Settings &gt; SSH and GPG keys &gt; new SSH key。同时还需要新建一个 YourName.github.io的仓库。（其实这个仓库的ssh下载地址就是 在 hexo&gt; _config.yml &gt; deploy &gt; repo配置的地址。 跳过提交密码每次提交代码时总会出现密码输入提示： 1Enter passphrase for key &apos;/c/Users/fujia/.ssh/id_rsa&apos; 如果想跳过这一步骤，需要进行下面设置： 打开 ssh-agent 1$ ssh-agent bash 如果给出错误提示：unable to start ssh-agent service...。就打开系统服务，找到OpenSSH Authentication Agent项，如果该项被禁止，把它改为自动。 修改之后，按顺序执行下面操作： 1$ ssh-keygen -p 提示输入 old passphrase 时输入旧密码，提示输入new passphrase 时，直接回车，确认密码时再次回车。 VSCode 插件VSCode编辑器美化 插件名 介绍 备注 vscode-icons 文件图标 - GlassIt-VSC 编辑器毛玻璃半透明效果 挺好看的 code相关 插件名 介绍 备注 search node_modules 快速搜索本地node_modules文件 ctrl+shift+p + node_module Bracket Pair Colorizer 成对括号颜色提示 - Vetur Vue提示 - JavaScript (ES6) code snippets 提供ES6的语法支持和片段 - eslint 格式化工具 - Beautify 格式化工具 - 调试相关 插件名 介绍 备注 open in browser 浏览器打开html页面 All+B debugger for chrome chrome 调试插件 神器，让你能在编辑器中调试 Live Server 建立本地服务器 为静态和动态页面提供实时刷新功能 Git相关 插件名 介绍 备注 Git history 看整个仓库文件的提交及修改历史 - 其他辅助工具 插件名 介绍 备注 Chinese (Simplified) Language Pack VSCode的简体中文包 - Markdown Preview Enhanced markdown 预览 - Markdown All in One 为编写markdown提供了一些快捷操作 -]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install MongoDB]]></title>
    <url>%2F2018%2F07%2F13%2Finstall-mongodb%2F</url>
    <content type="text"><![CDATA[前言首先，我们需要清楚的是数据库服务器和数据库服务器驱动。 在官网下载数据库服务器，本地安装 关联数据库服务器和数据存储位置，也就是建好数据存放的目录，然后把路径告诉数据库服务器,启动服务器守护进程mongod 使用命令行操作数据库进行增删改查等操作 实际开发中，我们是不会这样子直接输入命令行的，所以我们要安装数据库驱动来协助开发。mongodb是官方为node环境指定的Mongo驱动。 在项目中成功安装好驱动后，就可以通过驱动连接数据库并进行相关数据库操作了。 系统win10 64位安装安装Mogodb service到官网下载安装包。安装的时候，如果不想放到默认路径，可以自己重新选择安装目录。 安装完成后，进入~安装目录/bin,里面都是些mongdb的运行程序: 启动数据库接下来我们要建立数据库服务器和数据存储地址的联系，在此之前，请先确保你的存储目录已经建好，因为MongoDB不会帮你新建，从而建联失败。例如我要把数据存在G:\mongodb\data\下，我就得先建好这个目录，确保它能被找到。另外我们还可以新建一个日志文件G:\mongodb\log\mongodb.log记录日志。目录建好后，运行MongoDB的守护进程mongod.exe，守护数据库服务器与这个地址的连接。如果你在~安装目录的\bin 目录下，你可以这样运行： 1&gt; .\mongod --dbpath g:\mongodb\data 但你应该不想每次都进入到该目录去运行mongod命令，解决办法是在环境变量中给path添加~安装目录\bin路径： 然后在任何位置都可以直接运行： 1&gt; mongod --dbpath g:\mongodb\data 如果希望看到更多帮助信息，可以这样查看： 1&gt; mongod --help Mongod线程启动后，会默认监听27017端口，这时候你用浏览器访问localhost:27017,会看到这句话 1It looks like you are trying to access MongoDB over HTTP on the native driver port. 不过每次都要指定路径也很麻烦，可以把这个设置写入windows服务里: 1mongod.exe --logpath g:\mongodb\log\mongodb.log --logappend --dbpath g:\mongodb\data --directoryperdb --serviceName mongodb -install 执行完后可以在控制面板的本地服务里看到新注册的服务: 注册完成后，数据库服务器其实已经在后台启动了。你可以在任务管理器里看到正在运行的进程： 回到命令行，在终端连接数据库： 1&gt; mongodb 成功连接后，你会看到一些数据库及连接相关信息： 123456MongoDB shell version v4.0.0connecting to: mongodb://127.0.0.1:27017MongoDB server version: 4.0.0Welcome to the MongoDB shell.For interactive help, type "help".... 至此，数据库正式启动完成，可以通过命令行操作数据库，或者你也可以起一个project，安装数据库驱动，用node来跑一个。 操作数据库你可以直接在命令行操作数据库，感兴趣的朋友可以参考官方的这份文档。具体的教程还是官网最好，这里就不赘述了。 数据库驱动mongodb是官方指定的node环境数据库驱动。跟着里面的教程敲一遍，mongodb的基本用法基本就到手了。这里也不赘述。注意，此时，前面通过命令行mongodb建立的数据库连接和这里是没关系的。实际上是两种连接数据库方式。如果能正确使用mongodb连接数据库，它会得到和文档一样的结果： 123456789101112const MongoClient = require('mongodb').MongoClientconst assert = require('assert')const url = 'mongodb://127.0.0.1:27017'const dbName = 'test' //数据安装完成后，会默认有一张test表MongoClient.connect(url, &#123; useNewUrlParser: true&#125;, (err, client) =&gt; &#123; assert.equal(null, err); console.log('Connected successfully to server'); client.close()&#125;) 正确运行会看到下面结果： 往后就是自己的事了，用mongodb做点有趣的事吧！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongoDB</tag>
      </tags>
  </entry>
</search>
